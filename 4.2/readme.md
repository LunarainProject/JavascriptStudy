# 함수

## 프로그래밍에서의 함수

함수의 입력 값을 **인수**라고 하고, 출력 값을 **반환 값**이라고 합니다. 인수와 반환값은 있을 수도, 없을 수도 있습니다.
> 함수를 명령어 다발로 이해하는 것이 좋습니다.

함수는 `function` 키워드를 이용하여 정의합니다.  

```
function square(x) { return x * x; }
```


함수는 인수를 여러 개 받을 수 있습니다. 인수 이름을 컴마로 구분하여 씁니다.

## 함수 정의의 끌어올림

함수는 문서의 어디에 정의되어있더라도 맨 위로 끌어올려집니다.

## 값으로써의 함수

자바스크립트에서 함수는 하나의 **객체**입니다. 함수를 선언하면 그 함수의 **이름**을 **변수 이름**으로 하는 **함수 객체**가 만들어집니다. 그리고 그 변수에 함수 객체의 참조가 저장됩니다.

```javascript
//function-as-value.js
function cube(x) { return x * x * x; }
var cu = cube;
console.log(cu(2)); //8
```

## 콜 바이 밸류

원시 값을 함수에 인수로 넘겼을 때, 그 값이 복사되어 인수로 넘어갑니다.

## 콜 바이 레퍼런스

객체를 인수로 넘기는 경우에는 객체가 복사되는 것이 아닌 그 참조가 전달됩니다. 따라서 함수 내에서 객체를 수정하면 이는 인자로 넘긴 객체 자체에 반영됩니다.

많은 인자를 함수에 넘기는 것은 인자의 순서를 모두 외워야 한다는 단점이 있습니다. 따라서 parameters 에 해당하는 객체를 만들고 그 객체를 인수로 넘기는 방법이 제안되고 있습니다.

## 변수의 유효 범위

변수에 접근할 수 있는 범위를 **유효 범위** (scope)라고 합니다.  
자바스크립트의 변수는 **전역 변수**와 **지역 변수**로 나뉩니다.  

`{ }` 안쪽을 **지역**(local), 바깥을 **전역**(global)으로 볼 수 있습니다.

자바스크립트에서는 전역에 정의된 변수를 지역에서 읽을 수 있습니다. 다만 전역에 존재하는 이름을 다시 한 번 지역에서 정의할 경우 전역을 가립니다.

지역의 변수를 전역에서 읽을 수는 없습니다. 다만 이럴 경우에는 2장에서 다루었듯이 변수 선언이 생략된 것처럼 행동하기 떄문에 조심해야 합니다.

## 함수 내의 변수 끌어올림

함수 내에서 정의된 지역 변수는 함수의 정의 첫머리로 끌어올려집니다. 변수 선언 생략 또한 동일한데, 조금 다른 점은 **함수 내에서 변수 정의가 생략된 경우 전역 변수로 선언됩니다.**

## 새로운 변수 선언자

### let 선언자
`let` 선언자는 변수를 선언하되, `var` 선언자와는 달리 정의보다 위에서 변수를 사용하게 되면 오류가 발생합니다. 또한 `var`선언자는 함수 내에서 전역에서 유효하지 않은 지역 변수를 만들 수 있는 것에 비하여 `let`선언자는 중괄호로 둘러싸인 스코프 내에서 지역 변수를 만들 수 있습니다.

> `let`은 끌어올려지지 않을 것 같이 쓰여 있으나 정확히는 `let`도 호이스팅이 발생합니다. 값이 대입되기 전까지 `undefined`가 되는 `var`과는 달리 값이 대입되는 순간 메모리가 확보되는 구조이기 때문입니다.

### const 선언자
`const`선언자는 반드시 선언과 동시에 초기화되어야 합니다.  `const`로 선언된 변수에는 단 한 번만 값을 할당할 수 있습니다.

`const`로 객체를 저장했을 경우 그 변수가 다른 객체를 저장하는 것은 불가능하나, 객체 내의 프로퍼티의 값을 바꾸는 것은 가능합니다. (C언어의 포인터 상수와도 같습니다.)
> 상수를 가리키는 포인터 vs 포인터 상수 개념 [보러 가기](https://m.blog.naver.com/sipack7297/220394609641)

`let`과 `const`선언자는 메모리 누수, 버그 발생의 위험성이 짙은 `var`을 완전히 대체하는, 비교적 안전한 선언자인 만큼 개발을 할 때에 `var`의 사용을 최대한 피하고 `let`과 `const`를 적절히 이용해야 합니다.

### 참고 : var, let, const 차이 이해하기

1. `var`는 함수 레벨 스코프이고`let`, `const`는 블럭 레벨 스코프입니다.  
2. `var`로 선언한 변수는 선언 전에 사용해도 에러가 나지 않지만`let`, `const`는 에러가 발생합니다.  
3. `var`는 이미 선언되어있는 이름과 같은 이름으로 변수를 또 선언해도 에러가 나지 않지만`let`, `const`는 이미 존재하는 변수와 같은 이름의 변수를 또 선언하면 에러가 납니다.  
4. `var`,`let`은 변수 선언시 초기 값을 주지 않아도 되지만 `const`는 반드시 초기값을 할당해야 합니다.  
5. `var`,`let`은 값을 다시 할당할 수 있지만 `const`는 한번 할당한 값은 변경할 수 없습니다(단, 객체 안에 프로퍼티가 변경되는 것까지 막지는 못합니다).  


## 함수 리터럴

**익명 함수** 또는 **무명 함수** 라고도 불리는 객체로 `값으로써의 함수`에서와 유사하지만 약간 다른 개념입니다. `값으로써의 함수`에서는 함수를 정의하고, 그 참조를 가지고 있는 변수를 이용하여 참조를 변수에 대입하였다면, 이번에는 **익명 함수**를 만들고 그것의 참조를 변수에 대입하는 것입니다. 따라서, 자동으로 생성되는 `참조를 가지고 있는 변수`가 생성되지 않습니다.

물론 익명 함수도 이름을 붙여서 생성할 수 있습니다. 당연한 이야기지만, 지역에서 생성된 익명 함수는 이름이 붙여져 있어도 그 이름으로 생성되는 변수는 지역 변수가 됩니다.

```javascript
//function-literal.js
function foo() {
    var sq = function(x) { return x * x; };
    var cu = function cube(x) { return x * x * x; };
    console.log(sq(3), cu(3));
}

foo();
//console.log(cube); <- error
```

### 출력 결과


## 객체의 메서드

메서드를 정의할 때에는 **함수 리터럴**을 대입합니다. 프로퍼티의 값으로 함수 리터럴을 쓰면 됩니다. 이를 호출할 때에는 `객체이름.프로퍼티이름();`의 형태로 호출합니다.

```javascript
//method.js
let circle = {
    center : { x:1, y:1 },
    radius : 3.5,
    area : function () {
        return Math.PI * this.radius * this.radius;
    }
};
console.log(circle.area());

circle.translate = function(a, b) {
    this.center.x=this.center.x+a;
    this.center.y=this.center.y+b;
}
circle.translate(1, 2);
console.log(circle.center);
```

### 출력 결과

```
38.48451000647496
{ x: 2, y: 3 }

```

메서드는 일반적으로 메서드가 속한 객체의 내부 데이터(프로퍼티 값)을 바꾸는 용도로 사용합니다. 객체의 밖에서 객체를 수정할 때에 의도치 않은 에러를 일으키지 않으려면 메서드를 통해서 객체에 접근해야 합니다. 이렇게 객체를 부품 삼아 프로그램을 만들어 가는 기법을 `객체 지향 프로그래밍`이라고 부릅니다.

`this`는 메서드가 자신의 객체에 접근할 때 객체 자체를 지칭하는 키워드입니다.
